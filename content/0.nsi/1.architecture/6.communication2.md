---
title: Protocoles de communication
navigation: false
description: "Expérimentation des protocoles de communication à l'aide des cartes micro:bit : comprendre pourquoi et comment structurer les échanges d'informations pour rendre les messages compréhensibles et exploitables."
links:
- label: 'Page 1'
  icon: 'i-lucide-circle'
  to: '/nsi/architecture/communication'
---

::tip
Comment deux ordinateurs communiquent-ils ?
::

::steps{level="3"}

### Code de base
::note
Ce code permet uniquement d'échanger des messages par radio. Il comporte des problèmes majeurs : 
- l'ensemble est inintelligible
- on ne sait pas qui est le destinataire ni l'émetteur
::
```py
from microbit import *
import radio

radio.on()  # Active la radio
radio.config(channel=10)  # Définit un canal (10 ici)

while True:
    if button_a.was_pressed():
        msg_envoi = input("Message ?")
        radio.send(msg_envoi)  # Envoie un message
    message = radio.receive() # Permet de vérifier régulièrement la réception d'un message
    if message:
        print(message)  # Affiche le message reçu dans la console
```

### Définition d'un protocole
::note
**Version 1**
- Le séparateur utilisé est le *symbole monétaire générique* `¤`
- La trame est définie ainsi : `DESTINATAIRE¤ÉMETTEUR¤MESSAGE`
- Le destinataire, l'émetteur et le message ne peuvent pas être vides
- `ping` est un nom réservé
- On ignore les messages qui ne respectent pas ce protocole
::

```py {6,15-16}
from microbit import *
import radio

radio.on()  # Active la radio
radio.config(channel=10)  # Définit un canal (10 ici)
SEP = '¤'

while True:
    if button_a.was_pressed():
        msg_envoi = input("Message ?")
        radio.send(msg_envoi)  # Envoie un message

    trame = radio.receive() # Permet de vérifier régulièrement la réception d'un message
    if trame:
        parts = trame.split(SEP)
        if len(parts) == 3 and parts[0] != '' and parts[1] != '' and parts[2] != '':
            print(parts[2])  
```

### Saisie du destinataire au moment de l'envoi du message
::note
Pour construire notre trame, nous devons désormais ajouter une étape de saisie : le pseudo du destinataire de notre message.
::


```py {11-13}
from microbit import *
import radio

radio.on()  # Active la radio
radio.config(channel=10)  # Définit un canal (10 ici)
SEP = '¤'
PSEUDO = 'Mathieu'

while True:
    if button_a.was_pressed():
        msg_envoi = input("Message ?")
        dest = input("Destinataire ?")
        radio.send(dest+SEP+PSEUDO+SEP+msg_envoi)  # Envoie une trame

    trame = radio.receive() # Permet de vérifier régulièrement la réception d'un message
    if trame:
        parts = trame.split(SEP)
        if len(parts) == 3 and parts[0] != '' and parts[1] != '' and parts[2] != '':
            if parts[0] == PSEUDO:
                print(parts[2])  
```

### Affichage des message qui nous concernent
::note
On ne veut pas polluer notre affichage avec des messages qui ne nous sont pas adressés.  
On définit donc notre nom d'utilisateur, et on affiche seulement les messages qui nous sont adressés.
::

```py {7,19}
from microbit import *
import radio

radio.on()  # Active la radio
radio.config(channel=10)  # Définit un canal (10 ici)
SEP = '¤'
PSEUDO = 'Mathieu'

while True:
    if button_a.was_pressed():
        msg_envoi = input("Message ?")
        dest = input("Destinataire ?")
        radio.send(dest+SEP+PSEUDO+SEP+msg_envoi)  # Envoie une trame

    trame = radio.receive() # Permet de vérifier régulièrement la réception d'un message
    if trame:
        parts = trame.split(SEP)
        if len(parts) == 3 and parts[0] != '' and parts[1] != '' and parts[2] != '':
            if parts[0] == PSEUDO:
                print(parts[2])  
```

### Signaler sa présence sur le réseau (WIP)
::note
Nous envoyons actuellement des messages aux personnes qui sont à portée de voix, qui sont capables de nous donner l'information de leur pseudonyme sur le réseau. Nous allons ajouter la fonctionnalité permettant de signaler sa présence sur le réseau, grâce à l'utilisation d'une **commande**, que nous appellerons `ping`.
<br>
"Envoyer un ping" revient à envoyer une trame au destinataire `ping`, avec le message correspondant à notre `pseudo`.
::

::warning
Cela signifie que `ping` devient un **nom réservé** : son utilisation comme pseudonyme doit être interdite.
::

```py {15-16}
from microbit import *
import radio

radio.on()  # Active la radio
radio.config(channel=10)  # Définit un canal (10 ici)
SEP = '¤'
PSEUDO = 'Mathieu'

while True:
    if button_a.was_pressed():
        msg_envoi = input("Message ?")
        dest = input("Destinataire ?")
        radio.send(dest+SEP+PSEUDO+SEP+msg_envoi)  # Envoie une trame

    if button_b.was_pressed():
        radio.send('ping'+SEP+PSEUDO)  # Envoie un ping pour signaler sa présence

    trame = radio.receive() # Permet de vérifier régulièrement la réception d'un message
    if trame:
        parts = trame.split(SEP)
        if len(parts) == 3 and parts[0] != '' and parts[1] != '' and parts[2] != '':
            if parts[0] == PSEUDO:
                print(parts[2])  
```

### Prise en compte du ping des autres
::note
Nous devons prendre en compte les `ping` et ajouter l'identifiant qui s'est signalé à nous à une liste, pour faciliter son utilisation.
::

### Sélection du destinataire
::note
Avec les `ping`, nous pouvons construire un **dictionnaire** des destinataires dans laquelle nous pourrons piocher le nôtre.
::

